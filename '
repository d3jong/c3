use chrono::{Local ,NaiveDate};
use chrono::Duration;
use chrono::format::ParseError;
use scanf::sscanf;

use crate::todo_list::todo::date;

#[derive(Debug, PartialEq, Clone, Default)]
pub struct Schedule {
    day: u32,
    done_date: Option<NaiveDate>,
    pub is_scheduled: bool,
}

struct ScheduleRest {
    schedule: Schedule,
    rest: String,
}

impl From<String> for ScheduleRest {

    fn from(input:String) -> ScheduleRest {
        let mut day = 0;
        let mut date_string = String::new();
        let mut is_scheduled = false;
        let mut rest = String::new();
        match input {
            _ if sscanf!(input.as_str(), "{}[DAILY {}]", rest, date_string).is_ok() => {
                day = 1;
                is_scheduled = true;
            }
            _ if sscanf!(input.as_str(), "{}[D{} {}]", rest, day, date_string).is_ok() => {
                is_scheduled = true;
            }
            _ => {},
        };
        let last_done = match date::parse(&date_string) {
            Ok(value) => Some(value),
            Err(_) => None
        };

        let schedule = Schedule {
            day,
            done_date: last_done,
            is_scheduled 
        };

        ScheduleRest {
            schedule,
            rest
        }
    }
}

impl Into<String> for Schedule {
    fn into(self) -> String {
        if self.is_scheduled {
            let date_str = date::format(self.done_date);
            match self.day {
                1 => format!(" [DAILY {date_str}]"),
                any => format!(" [D{any} {date_str}]"),
            }
        } else {
            String::new()
        }
    }
}

impl Schedule {
    pub fn new() -> Self {
        Schedule {
            day: 0,
            done_date: None,
            is_scheduled: false, 
        }
    }
    pub fn display(&self) -> String{
        if !self.is_scheduled {
            return String::new();
        }
        let last_save = if let Some(done_date) = self.done_date {
            date::current() - done_date
        } else {
            Duration::zero()
        };
        let inner_str = match last_save.num_days() {
            0 => String::new(),
            1 => String::from(", last done yesterday"),
            any => format!(", last done {} days ago", any)
        };
        match self.day {
            1 =>format!(" (Daily{inner_str})"),
            day =>format!(" (Each {} day {inner_str})", self.day),
        }
        
        format!(" (Each {} day {inner_str})", self.day)
    }

    pub fn match_message(input: &mut String) -> Self {
        let ScheduleRest { schedule, rest } = ScheduleRest::from(input.clone());
        input.clone_from(&rest);
        schedule
    }
}
